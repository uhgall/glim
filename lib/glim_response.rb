require_relative 'globals'

class GlimResponseError < StandardError
  def initialize(raw_response, message = "Unexpected GlimResponse")
    @raw_response = raw_response
    s = "\n"+JSON.pretty_generate(raw_response)
    putt :error, "GlimResponseError: #{message}"
    super(message+s)
  end
end

class GlimResponseFuture

  attr_reader :request, :thread
  
  def cached?
    @cached
  end
  
  # if you pass a block, it is called immediately after the response is available
  def initialize(request, &block)
    raise "req shoud be a GlimRequest" unless request.is_a?(GlimRequest)
    @request = request
    request_fn = log_request_hash
    response_class = request.response_class
    time_request_sent = Time.now
    cached_response = request.maybe_cached_response
    prefer_cached_response = request.prefer_cached_response

    if prefer_cached_response && cached_response
      putt :cache, "Using cached response for key: #{cache_key}"
      raw_response = cached_response.with_indifferent_access
      raw_response[:glim][:cached] = true
      log_raw_response(raw_response)
      response = response_class.new(request,raw_response)
      block.call(response) if block_given?
      @cached = true
      @response = response
    else
      if cached_response 
        putt :cache, "Cache hit for key #{cache_key} but performing RPC because prefer_cached_response=#{prefer_cached_response}"
      else
        putt :cache, "Cache miss for key #{cache_key}, performing RPC"
      end
      putt :rpc, "RPC for #{request}"
      original_call_stack = caller
      @thread = Thread.new do
        begin
          raw_response = response_class.get_raw_response_from_api(request)
        rescue  => e
          putt :error, "Error in async_send_request_to_api: #{e.message}"
          putt :error, e.backtrace.join("\n")
          raw_response = {error: e.message, glim: {backtrace: e.backtrace, original_call_stack:, request_fn:  }}
        end    
        raw_response[:glim] ||= {}
        raw_response[:glim][:time_spent] = Time.now - time_request_sent    
        raw_response[:glim][:cached] = false
        if !request.no_cache && !raw_response[:error]
          save_raw_response_to_cache(raw_response) unless request.no_cache
        end
        log_raw_response(raw_response)
        response = response_class.new(request,raw_response)
        block.call(response) if block_given?
        response
      end # when @thread ends, it's set to response
    end
  end

  def context
    request.context
  end

  def cache_key
    request.cache_key
  end

  # caching
  def cache_path
    context.cache_path
  end

  def save_raw_response_to_cache(raw_response)
    putt :cache, "Saving response to cache for key: #{cache_key}"
    #make sure cache_path exists
    FileUtils.mkdir_p(cache_path) unless File.exist?(cache_path)
    cache_file = File.join(cache_path, "#{cache_key}.json")
    File.write(cache_file, raw_response.to_json)
  end

  def response_available?
    @response || (@thread&.status == false)
  end

  # deprecated
  def response
    await_response
  end

  def await_response
    # if it's a cache hit, then the response is already set. Otherwise, wait for the thread to finish.
    @response ||= begin
      @thread.join unless @thread.status == false
      @thread.value
    end
  end

  def log_request_hash
    s = "# request_hash generated by #{request.class} with #{request.request_details.class}\n"
    s += JSON.pretty_generate(request.request_hash)
    return request.save_log_file("request_hash.json", s)
  end

  def log_raw_response(raw_response)
    request.save_log_file("raw_response.json", JSON.pretty_generate(raw_response))
  end

end

# if the response exists, then all the data is already there
class GlimResponse
  extend Delegation

  private def must_implement_in_subclass
    raise NotImplementedError, "You must implement #{self.class}##{__method__}"
  end

  attr_reader :request, :params, :raw_response

  # two ways to create this:
  # 1. from a cached raw response
  # 2. from a raw response that was obtained from the API
  def initialize(request,raw_response)
    raise "request shoud be a GlimRequest, is #{request}" unless request.is_a?(GlimRequest)
    @request = request
    @raw_response = raw_response.with_indifferent_access
    _process_raw_response # implemented by subclass
    if !error?
      request.context._add_to_cost(total_cost, cached: cached?)
      log_summary_append
      log_completion
    end
  end

  def cached?
    @raw_response[:glim][:cached]
  end

  # call this in any method that shoudn't be called if there was an error
  def raise_if_error
    if error?
      raise GlimResponseError.new(raw_response.except(:backtrace), "GlimResponse had an error earlier. Your code should check response.error? before calling this.")
    end
  end

  def raise_error(msg)
    raise GlimResponseError.new(raw_response, msg)
  end
  
  # logging

  def log_completion
    request.save_log_file("completion.txt", completion)
  end

  def log_summary_append
    templ = request.template_name ? request.template_name+".erb" : "no_template"
    s = "#{responding_llm_name}, #{templ}"
    if !error?
      tps = completion_tokens / time_spent
      s += ", #{prompt_tokens}, prompt_tokens + , #{completion_tokens}, completion_tokens = $"
      if false && cached_response
        s += ",0,0,cached, , , "
      else
        # even when cached, useful to know cost
        _total_cost = request.cost_per_prompt_token * prompt_tokens + request.cost_per_completion_token * completion_tokens
        s += ",#{_total_cost}, #{time_spent.round(3)}, seconds, #{tps}, tokens/s"
      end
    else
      s += ',ERROR,,,,,,, '
    end
    s += ", #{request.log_base_this_request}"
    context.log_line_to_summary(s)
  end

  # anomalies
  delegate :log_base_this_request, :anomaly_base_this_request, :context, to: :request
  attr_reader :anomalies



  def add_anomaly(severity, details)
    putt :anomaly, "#{severity}, #{details}"
    add_anomalies([[severity, details]])
  end

  def add_anomalies(anomalies)
    return unless anomalies && anomalies.length > 0
    if !@anomalies
      @anomalies = []
      putt :log, "FileUtils.cp_r(#{log_base_this_request}, #{anomaly_base_this_request})"
      error("Source directory = #{log_base_this_request} does not exist.") unless Dir.exist?(log_base_this_request)
      FileUtils.mkdir_p(anomaly_base_this_request) unless Dir.exist?(anomaly_base_this_request)    
      FileUtils.cp_r(Dir[log_base_this_request + "/*"], anomaly_base_this_request)
    end
    @anomalies += anomalies
    File.write(File.join(anomaly_base_this_request, "anomaly_info.txt"), JSON.pretty_generate(@anomalies))
  end

  def total_anomaly_severity
    @anomalies&.map{|a| a[0]}.sum || 0
  end

  def completion
    must_implement_in_subclass
  end

  def time_spent
    @time_spent ||= raw_response[:glim][:time_spent]
  end

  def extract_files_from_completion(base_path_for_saving)
    raise_if_error
    log_path_for_saving = File.join(request.log_base_this_request, "extracted")
    return extract_files(input: completion, base_path_for_saving:, log_path_for_saving:)
  end

  def extract_field_from_completion(field_name)
    raise_if_error
    return extract_between_markers(completion, "<#{field_name}>", "</#{field_name}>")
  end

  def extract_csv_data_from_field(field_name = nil)
    if field_name
      csv = extract_field_from_completion(field_name)
    else
      fields = extract_fields(completion)
      if fields.length == 0
        add_anomaly(0.5, "No fields found in completion")
        return nil
      elsif fields.length > 1
        add_anomaly(0.2, "Multiple fields found in completion: #{fields}, using #{fields.keys.first}")
      end
      csv = fields.values.first
    end
    result = []
    for row in csv.split("\n")
        next if row.strip.length == 0
        result << row.split(",").map(&:strip)
    end
    columns_counts = result.map(&:length).uniq
    if columns_counts.length > 1
      add_anomaly(0.5, "CSV data has rows with different numbers of columns: #{columns_counts.join','}")
    end
    return result
  end

  # fields we can get from the response
  def responding_llm_name
    must_implement_in_subclass
  end

  def total_tokens
    prompt_tokens + completion_tokens
  end

  def total_cost
    prompt_tokens * request.cost_per_prompt_token + completion_tokens * request.cost_per_completion_token
  end

  def full_prompt_as_text
    # TODO -- add chat history
    request.prompt
  end
  

end

